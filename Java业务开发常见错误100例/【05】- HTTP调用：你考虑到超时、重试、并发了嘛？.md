# HTTP

> 与执行本地方法不同，进行HTTP调用本质上是通过HTTP协议进行一次网络请求。网络请求必然有超时的可能性，因此必须考虑到这三点：
>
> - 首先，框架设置的默认超时是否合理
> - 其次，考虑到网络的不稳定，超时后的请求重试是一个不错的选择，但需要考虑服务端接口的幂等性设计是否允许我们重试
> - 最后，需要考虑框架是否会像浏览器那样限制并发连接数，以免在服务并发很大的情况下，HTTP调用的并发数限制称为瓶颈

# Feign



# Apache HttpClient

> _配置连接超时和读取超时参数的学问_ 
>
> > 对于HTTP调用，虽然应用层走的是HTTP、协议，但网络层面始终是TCP/IP协议。TCP/IP是面向连接的协议，在传输数据之前需要建立连接。几乎所有的网络框架都会提供这么两个参数：
> >
> > - 连接超时参数ConnectTimeout，让用户配置建连阶段的最长等待时间
> > - 读取超时参数ReadTimeout，用来控制从Socket上读取数据的最长等待时间
>
> **连接超时参数和连接超时的误区有这么两个**
>
> - 连接超时配置得特别长，比如60秒
> - 排查连接超时问题，却没理清连的是哪里
>
> **读取超时参数和读取超时的误区**
>
> - 认为读取超时，服务端的执行就会中断
> - 认为读取超时只是Socket网络层面的概念，是数据传输的最长耗时，故将其配置得非常短，比如100毫秒
> - 认为超时时间越长任务接口成功率就越高，将读取超时参数配置得太长



# Feign和Ribbon配合使用，怎么配置超时

> **复杂之处**
>
> > Feign自己有两个超时参数，它使用的负载均衡组件Ribbon本身还有相关配置。那么，这些配置的优先级是怎样的，又哪些什么坑呢？
>
> Spring 需要指定版本～
>
> **如果要修改Feign客户端默认的两个全局超时时间**
>
> > ```java
> > feign.client.config.default.read-timeout=3000
> > feign.client.config.default.connect-timeout=3000
> > ```
>
> **坑点**
>
> > - 默认情况下Feign的读取超时是1秒，如此短的读取超时算是坑点一
> > - 如果要配置Feign的读取超时，就必须同时配置连接超时，才能生效
> > - 单独的超时可以覆盖全局超时，这符合预期
> > - 除了可以配置Feign，也可以配置Ribbon组件的参数来修改两个超时时间。这样里的坑点是，参数首字母要大写，和Feign的配置不同
> > - 同时配置Feign和Ribbon的超时，以Feign为准
> >
> > - 但如果同时配置Feign和Ribbon时，Feign未生效，可能是因为单独配置了Feign的超时时间，并未生效
>
> **是否知道Ribbon会自动重试请求呢？**
>
> > 一些HTTP客户端往往会内置一些重试策略，其初衷是好的，毕竟因为网络问题导致丢包虽然频繁但持续时间短，往往重试下第二次就能成功，但一定要小心这种自作主张是否符合预期。
> >
> > 比如短信重复发送，见项目test2020101401
> >
> > **解决办法**
> >
> > - 把发短信接口从Get改为Post。其实，这里还有一个API设计问题，有状态的API接口不应该定义为Get。根据HTTP协议的规范，Get请求用于数据查询，而Post才是吧数据提交到服务端用于修改或新增。选择Get还是Post的依据，应该是API的行为，而不是参数大小。
> > - 将MaxAutoRetriesNextServer参数配置为0，禁用服务调用失败后在下一个服务端节点的自动重试。在配置文件中添加一行即可：`ribbon.MaxAutoRetriesNextServer=0`

# 并发限制了爬虫的抓取能力

> 除了超时和重试的坑，进行HTTP请求调用还有一个常见的问题，并发数的限制导致程序的处理能力上不去。



