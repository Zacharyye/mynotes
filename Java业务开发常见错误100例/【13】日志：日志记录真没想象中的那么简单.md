> **容易出错的三个方面**
>
> - 日志框架众多，不同的类库可能会使用不同的日志框架，如何兼容是一个问题
> - 配置复杂且容易出错。日志配置文件通常很复杂～
> - 日志记录本身就有些误区，比如没考虑到日志内容获取的代价、胡乱使用日志级别。
>
> Logback、Log4j、Log4j2、commons-logging、JDK自带的java.util.logging等，都是Java体系的日志框架。
>
> **SLF4J**：
>
> - 提供了统一的日志门面API，实现了中立的日志记录API
> - 桥接功能，用来把各种日志框架的API桥接到SLF4J API。这样一来，即便程序中使用了各种日志API记录日志，最终都可以桥接到SLF4J门面API
> - 适配功能，可以实现SLF4J API和实际日志框架的绑定。SLF4J只是日志标准，最终还是需要一个实际的日志框架。日志框架本身没有实现SLF4J API，需要一个前置转换。Logback就是按照SLF4J API标准实现的。Logback就是按照SLF4JAPI标准实现的，因此不需要绑定模块做转换。
> - 注意：桥接和适配只能使用一种？

### 为什么日志会重复记录？

> 非常常见，不但给查看日志和统计工作带来不必要的麻烦，还会增加磁盘和日志收集系统的负担。
>
> **第一个案例，logger配置继承关系导致日志重复记录**
>
> **第二个案例，错误配置LevelFilter造成日志重复记录**

### 使用异步日志改善性能的坑

> *磁盘IO性能较差、日志量又很大的情况下，如何记录日志的问题？*
>
> **AsyncAppender**
>
> > 异步日志记录，性能比较好，但是也有坑
> >
> > - 记录异步日志撑爆内存
> > - 记录异步日志出现日志丢失
> > - 记录异步日志出现阻塞
> >
> > 问题在于：AsyncAppender提供了一些配置参数，没用对
> >
> > - includeCallerData用于控制是否收集调用方数据，默认是false，此时方法行号、方法名等信息将不能显示。
> > - queueSize用于控制阻塞队列大小，使用的ArrayBlockingQueue阻塞队列，默认大小是256，即内存中最多保存256条日志
> > - discardingThreshold是控制丢弃日志的阈值，主要是防止队列满后阻塞。默认情况下，队列剩余量低于队列长度的20%，就会丢弃TRACE、DEBUG和INFO级别的日志。
> > - neverBlock用于控制队列满的时候，加入的数据是否值接丢弃，不会阻塞等待，默认是false。这里需要注意一下offer方法和put方法的区别，当队列满的时候offer方法不阻塞，而put方法会阻塞；neverBlock为true时，使用offer方法。
> >
> > **queueSize、discardingThreshold和neverBlock这三个参数息息相关，务必按需进行设置和取舍，到底是性能为先，还是数据不丢为先：** 
> >
> > - 如果考虑绝对性能为先，那就设置neverBlock为true，永b不阻塞
> > - 如果考虑绝对不丢数据为先，那就设置discardingThreshold为0，即使是<=INFO的级别日志也不会丢，但最好把queueSize设置大一点，毕竟默认的queueSize显然太小，太容易阻塞
> > - 如果希望兼顾两者，可以丢弃不重要的日志，把queueSize设置大一点，再设置一个合理的discardingThreshold。

### 使用日志占位符就不需要进行日志级别判断了？

> 建议事先判断，不然即使使用占位符，获取参数的过程也是要耗费时间的