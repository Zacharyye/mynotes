> 统一打上try...catch...捕获所有异常记录日志；或者使用AOP来进行类似的“统一异常处理“ -- 不可取

### 捕获和处理异常容易犯的错

> 1. "统一异常处理" - 不在业务代码层面考虑异常处里，仅在框架层面粗犷捕获和处理异常。
>    - @RestControllerAdvice 和 @ExceptionHandler，可以控制全局捕获异常
> 2. 捕获了异常后直接生吞。在任何时候，捕获了异常都不应该生吞，也就是直接丢弃异常不记录、不抛出。
> 3. 丢弃异常的原始信息 -- 不行
> 4. 抛出异常时不指定任何消息 -- 🙅‍♂️
> 5. 除了通过日志正确记录原始异常信息外，通常还有三种处理方式
>    - 转换 - 即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消息，而不是随便抛一个无关或没有任何信息的异常，并最好通过cause关联老异常
>    - 重试 - 即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试
>    - 恢复 - 即尝试进行降级处理，或使用默认值来替代原始数据

### 小心finally中的异常

> **finally中的异常会覆盖try中出现的异常，导致问题不明显**
>
> - 为什么？
>   - 因为一个方法无法出现两个异常。修复方式是，finally代码块自己负责异常捕获和处理。
> - 修复方式
>   - finally代码块自己负责异常捕获和处理
>   - 可以把try中的异常作为主异常抛出，使用addSuppressed方法把finally中的异常附加到主异常上
>   - 以上正是try-with-resources语句的做法

### 千万别把异常定义为静态变量

> 可能导致异常栈信息错乱？共享了？

### 提交线程池的任务出了异常会怎么样？

> - 原线程因异常退出了，线程池重新创建了一个线程
>
> - 因为没有手动捕获异常进行处理，ThreadGroup进行了未捕获异常的默认处理，向标准错误输出打印了出现异常的线程名称和异常信息。显然，这种没有以统一的错误日志格式记录错误信息打印出来的形式，对生产级代码是不合适的
>
> **修复方式**
>
> - 以execute方法提交到线程池的异步任务，最好在任务内部做好异常处理
>
>   - ```java
>     new ThreadFactoryBuilder()
>       .setNameFormat(prefix+"%d")
>       .setUncaughtExceptionHandler((thread, throwable)-> log.error("ThreadPool {} got exception", thread, throwable))
>       .get()
>     ```

> - 设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序
>
> - ```java
>   static {
>    Thread.setDefaultUncaughtExceptionHandler((thread, throwable)-> log.error("Thread {} got exception", thread, throwable));
>   }
>   ```
>
> 通过线程池ExecutorService的execute方法提交任务到线程池处理，如果出现异常会导致线程推出，控制台输出中可以看到异常信息。那么，把execute方法改为submit，线程还会退出吗，异常还能被处理程序捕获到吗？
>
> - 修改代码后重新执行程序可以看到如下日志，说明线程没退出，异常也没记录被生吞了。
>   - 为什么？
>   - 查看源码发现，在执行任务出现异常之后，异常存到了一个outcome字段中，只有在调用get方法获取FutureTask结果的时候，才会以ExecutionException的形式重新抛出异常。

