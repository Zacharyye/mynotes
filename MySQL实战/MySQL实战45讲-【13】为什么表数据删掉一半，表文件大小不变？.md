> ​	数据库表的空间回收 - InnoDB，一个InnoDB表包含两部分，即：表结构定义和数据

> ​	MySQL8.0版本以前，表结构是存在以.frm后缀的文件里。而MySQL 8.0版本，则已经允许把表结构定义放在系统数据表中了。因为表结构定义占用的空间很小，今天主要讨论的是表数据。
>
> ？问题：数据库占用空间太大，把最大的表删掉了一半的数据。怎么表文件的大小还是没变。

# 参数innodb_file_per_table

>  表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的：
>
> - 这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
> - 这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以.lbd为后缀的文件中。
> - 从MySQL5.6.6版本开始，它的默认值就是ON了
> - 建议不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的

## 数据删除流程

> 在删除整个表的时候，可以使用drop table命令回收表空间，但是我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了问题：表中的数据被删除了，但是表空间却没有被回收。
>
> InnoDB里的数据都是B+树的结构组织的
>
> 删除记录-标记删除，之后可能会复用这个位置，但是条件限制；如果删除整页，页会被标记为可服用，无条件复用 。
>
> delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。
>
> 不止是删除数据会造成空洞，插入数据也会。
>
> ![img](https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png)
>
> 因为pageA满了，再插入一个ID是550的数据时，就不得不再申请一个新的页面pageB来保存数据了。页分裂完成后，pageA的末尾就留下了空洞。
>
> 更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，也会造成空洞。
>
> 也就是说，经过大量增删改的表，都是可能存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。
>
> 而重建表，就可以达到这样的目的。

## 重建表 

> Alter table A engine=InnoDB == alter table A engine=innodb,algorithm=inplace;
>
> 对应的alter table A engine=innodbm,algorithm=copy;
>
> Online 和 inplace~



